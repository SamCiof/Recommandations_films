from components.base_component import BaseComponent
import streamlit as st

class TFIDFComponent(BaseComponent):
    def __init__(self):
        super().__init__("Modèle Tfidf collaboratif")

    def display(self):
        st.header(self.title)
        st.markdown(self.get_model_test(), unsafe_allow_html=True)
        st.markdown(self.get_installation_libraries(), unsafe_allow_html=True)
        st.markdown(self.get_loading_and_preparing_data(), unsafe_allow_html=True)
        st.markdown(self.get_preparation_features(), unsafe_allow_html=True)
        st.markdown(self.get_model_creation(), unsafe_allow_html=True)
        st.markdown(self.get_final_model_test(), unsafe_allow_html=True)
        st.markdown(self.get_model_interpretability_part1(), unsafe_allow_html=True)
        st.image('/home/dstrec/dstrec/060_app_streamlit/images/tfidf_star_trek_score_comparison.png', caption='Visualisation Tfidf 1')
        st.markdown(self.get_model_interpretability_part2(), unsafe_allow_html=True)
        st.image('/home/dstrec/dstrec/060_app_streamlit/images/tfidf_star_trek_score_comparison_with_variations.png', caption='Visualisation Tfidf 2')
        st.markdown(self.get_model_interpretability_part3(), unsafe_allow_html=True)
        st.markdown(self.get_conclusion(), unsafe_allow_html=True)

    def get_model_test(self):
        return (""" 
        ### Test du modèle
        Dans le cadre de notre projet sur les systèmes de recommandation, nous avons comme objectif de créer un système capable de fournir des recommandations personnalisées aux utilisateurs.
        Nous avons testé plusieurs modélisations basées sur le jeu de données disponible. Certaines modélisations n’ont pas donné de résultats concluants.  L’un des modèles testés est un modèle basé sur le filtrage collaboratif.
        Ce modèle utilise notamment la fonction TfidfVectorizer. Cette fonction convertit le texte en vecteurs de mots.
        """)
    
    def get_installation_libraries(self):
        return ("""
        **Installation et Importation des Librairies :**\n
        Nous avons préparé notre environnement de développement en installant les librairies nécessaires, en particulier pour le traitement des données et l'apprentissage automatique.
        """)
    
    def get_loading_and_preparing_data(self):
        return ("""
        **Chargement et Préparation des données :**\n
        Nous avons utilisé les données préalablement nettoyées et préparées dans le chapitre décrit précédemment.
        """)
    
    def get_preparation_features(self):
        return ("""
        **Préparation des Features :**\n
        Nous avons traité les colonnes du DataFrame en fonction de leur type à l’exception de la colonne imdbId, title, averageRating et numVotes.
        Pour les colonnes actor_actress, producer et director, nous avons effectué un traitement des données afin que chaque nom soit unique. Nous avons également retraité les différents genres. 
        """)
    
    def get_model_creation(self):
        return ("""
        **Création du Modèle :**\n
        Nous avons développé une fonction get_recommendations pour calculer la similarité COSINE entre les films et générer une liste de films recommandés basés sur le titre de film donné. Cette fonction récupère le vecteur de 
        caractéristiques du film demandé et calcule sa similarité avec tous les autres films dans la base de données, renvoyant les 10 recommandations les plus proches.
        """)
    
    def get_final_model_test(self):
        return ("""
        **Tests du Modèle :**\n
        Des tests ont été réalisés pour démontrer la fonctionnalité de notre système de recommandation. Nous avons pris comme modèle exemple le film “Star Trek”
        """)
    
    def get_model_interpretability_part1(self):
        return ("""
        ### Interprétabilité du modèle
        Nous nous sommes penchés sur l'interprétabilité du modèle pour nous assurer que les recommandations faites sont non seulement précises mais aussi compréhensibles et justifiables.
        Nous avons donc voulu tester les features sur lesquelles s’appuient les recommandations. 
        Nous avons déterminé qu’il existe 4 catégories de features : producer, director, actor_actress, genres (regroupement de l’ensemble des genres attribués au film)
        
        Pour tester les différents éléments intervenant dans le calcul du score, nous avons fait varier les éléments pris en compte dans le calcul du score pour le film “Star Trek” : nous avons enlevé successivement le producteur, 
        le director, les actor_actress et les genres. A chaque fois, nous avons calculé le score suite au changement de donnée
        """)
    
    def get_model_interpretability_part2(self):
        return (""" 
        Chaque élément intervient et contribue à l’élaboration du score de la recommandation. 
        Pour le film Star Trek, l'élément le plus déterminant est les actor_actress.
        Le modèle semble bien équilibré et utilise bien l’ensemble des informations.

        Un second test a été effectué : calculer des scores avec certains éléments et comparer les variations. Pour cela, on réalise le test suivant : 
        1. on enregistre les recommandations originales avec l’ensemble des informations
        2. on recalcule les scores en supprimant la variable “genres”
        
        On obtient les résultats suivants : 
        """)
    
    def get_model_interpretability_part3(self):
        return (""" 
        Le fait de retirer les genres fait donc varier les scores et les recommandations. 
        
        On peut donc conclure avec les tests d’'interprétabilité effectués que le modèle de recommandations s’appuie sur les informations et les caractéristiques des films pour faire ses recommandations. Les recommandations 
        produites sont donc fiables et peuvent être expliquées.
        """)

    def get_conclusion(self):
        return ("""
        ### Conclusion
        Le modèle utilise l’ensemble des éléments dans son calcul de score de similarité. Le modèle développé a été testé sur différents films et il offre de bonnes recommandations. 
        """)