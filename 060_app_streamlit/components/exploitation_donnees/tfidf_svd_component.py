from components.base_component import BaseComponent
import streamlit as st

class TFIDF_SVDComponent(BaseComponent):
    def __init__(self):
        super().__init__("Modèle Tfidf avec SVD")
    
    def display(self):
        st.header(self.title)
        st.markdown(self.get_model_test(), unsafe_allow_html=True)
        st.markdown(self.get_installation_libraries(), unsafe_allow_html=True)
        st.markdown(self.get_loading_and_preparing_data(), unsafe_allow_html=True)
        st.markdown(self.get_model_setup(), unsafe_allow_html=True)
        st.markdown(self.get_creating_weights(), unsafe_allow_html=True)
        st.markdown(self.get_preparation_features(), unsafe_allow_html=True)
        st.markdown(self.get_model_creation(), unsafe_allow_html=True)
        st.markdown(self.get_final_model_test(), unsafe_allow_html=True)
        st.markdown(self.get_model_interpretability_part1(), unsafe_allow_html=True)
        st.image('/home/dstrec/dstrec/060_app_streamlit/images/tfidf_svd_similarity_score_for_toy_story.png', caption='Visualisation Tfidf SVD 1')
        st.markdown(self.get_model_interpretability_part2(), unsafe_allow_html=True)
        st.image('/home/dstrec/dstrec/060_app_streamlit/images/tfidf_svd_ contribution_weight_to_similarity_for_toy_story.png', caption='Visualisation Tfidf SVD 2')
        st.markdown(self.get_model_interpretability_part3(), unsafe_allow_html=True)
        st.markdown(self.get_conclusion(), unsafe_allow_html=True)
    
    def get_model_test(self):
        return ("""
        ### Test du modèle
        Dans le cadre de notre projet sur les systèmes de recommandation, nous avons tenté d’élaborer un modèle hybride combinant les techniques de filtrage basées sur le contenu 
        et le filtrage collaboratif. 
        Ce modèle utilise notamment TfidfVectorizer et TruncatedSVD pour analyser et réduire la dimensionnalité des données relatives aux films. Notre objectif était de créer un 
        système capable de fournir des recommandations précises et personnalisées aux utilisateurs.
        Nous avons dans un premier temps fait deux tests de modèles qui n’étaient pas concluants. Le premier ne donnait pas de résultats assez bons et le second ne fonctionnait pas 
        en raison d’un problème de mémoire. Nous avons tout de même laissé en commentaire, à la fin de notre fichier, les lignes de codes créées pour ces tests.
        """)
    
    def get_installation_libraries(self):
        return ("""
        **Installation et importation des librairies :**\n
        Nous avons préparé notre environnement de développement en installant les librairies nécessaires, en particulier pour le traitement des données et l'apprentissage automatique.
        """)
    
    def get_loading_and_preparing_data(self):
        return ("""
        **Chargement et Préparation des données :**\n
        Après avoir chargé nos données qui ont été nettoyées et préparées au préalable, nous avons également supprimé la colonne imdbId afin qu’elle n’influe pas sur notre modèle. 
        Ce nettoyage était essentiel pour garantir l'intégrité des données utilisées dans les recommandations.
        """)
    
    def get_model_setup(self):
        return ("""
        **Configuration du Modèle TF-IDF et SVD :**\n
        Nous avons configuré TfidfVectorizer pour réduire les caractéristiques des descriptions textuelles à 5000 termes maximaux, afin de capturer l'essence du contenu sans surcharger 
        le modèle de données inutiles. Ensuite, TruncatedSVD a été utilisé pour réduire le nombre de dimensions à 100 composantes principales, optimisant ainsi l'efficacité de la 
        transformation des données.
        """)

    def get_creating_weights(self):
        return ("""
        **Création des Poids des Variables :**\n
        Les poids ont été attribués à chaque variable pour différencier leur impact dans le calcul des recommandations. Les genres comme Action, Adventure, etc., ont reçu un poids de 3, 
        reflétant leur importance dans la préférence des utilisateurs. D'autres attributs comme averageRating et director ont reçu des poids de 2, tandis que les autres colonnes ont reçu 
        des poids de 1, pour moduler leur influence sur le système de recommandation. Ceci nous permet de déterminer selon nous les caractéristiques qui nous semblent les plus importantes 
        à prendre en compte pour effectuer notre recommandation. Le titre quant à lui a reçu un poids de 0 puisqu’il ne doit pas intervenir dans la recommandation mais uniquement en tant 
        que cible de sortie de notre modèle.
        """)

    def get_preparation_features(self):
        return ("""
        **Préparation des Features :**\n
        Nous avons traité les colonnes du DataFrame en fonction de leur type. Pour les colonnes de type objet, nous avons appliqué TfidfVectorizer suivi de TruncatedSVD pour les transformer 
        en un espace latent réduit. Pour les colonnes numériques, nous avons appliqué une pondération directe en multipliant les valeurs par leurs poids respectifs. Ces matrices transformées 
        ont ensuite été concaténées en une seule matrice sparse.
        """)

    def get_model_creation(self):
        return ("""
        **Création du Modèle Hybride de Recommandation :**\n
        Nous avons développé une fonction get_recommendations pour calculer la similarité cosine entre les films et générer une liste de films recommandés basés sur un titre de film donné. 
        Cette fonction récupère le vecteur de caractéristiques du film demandé et calcule sa similarité avec tous les autres films dans la base de données, renvoyant les 10 recommandations 
        les plus proches.
        """)
    
    def get_final_model_test(self):
        return ("""
        **Tests du Modèle :**\n
        Des tests ont été réalisés pour démontrer la fonctionnalité de notre système de recommandation. Par exemple, des recommandations pour des films comme "Miss Jerry", "Toy Story" et 
        "Inception" ont été générées pour illustrer la capacité du modèle à identifier des films pertinents basés sur différents genres et styles.
        """)
    
    def get_model_interpretability_part1(self):
        return ("""
        ### Interprétabilité du modèle
        Nous nous sommes penchés sur l'interprétabilité du modèle pour nous assurer que les recommandations faites sont non seulement précises mais aussi compréhensibles et justifiables.
        Nous avons commencé par explorer l'interprétabilité relative à la similarité des films. Pour cela, nous avons calculé la similarité cosinus entre les vecteurs caractéristiques des 
        films. L’objectif était de comprendre pourquoi certains films sont recommandés lorsqu'on cherche des suggestions similaires à un film donné, en l'occurrence Toy Story. 
        En sélectionnant un sous-ensemble de films potentiellement proches, nous avons pu observer que les scores de similarité étaient élevés pour des films comme Toy Story 2, Cars et 
        A Bug's Life. Ces résultats sont conformes à nos attentes, car ces films partagent des éléments communs avec Toy Story, tels que le genre, le réalisateur, ou des thèmes narratifs 
        similaires. Cette analyse confirme que le modèle propose des recommandations logiques basées sur des similarités tangibles.
        """)
    
    def get_model_interpretability_part2(self):
        return (""" 
        Ensuite, nous nous sommes penchés sur l'interprétabilité relative aux poids attribués aux différentes caractéristiques des films, comme le réalisateur, le genre ou le producteur. 
        Nous avons mené des tests en ajustant dynamiquement les poids de ces caractéristiques pour observer les modifications dans les recommandations. Par exemple, nous avons considérablement 
        augmenté le poids du réalisateur pour voir comment cela influencerait les suggestions. Les résultats ont montré que cette modification faisait ressortir des films réalisés par le même 
        réalisateur ou partageant des similarités stylistiques ou thématiques avec Toy Story. Cela démontre que le modèle est sensible aux variations de poids des caractéristiques, ce qui permet 
        de mieux comprendre quels éléments influencent le plus les recommandations.
        Pour rendre ces analyses encore plus transparentes, nous avons réalisé une visualisation des effets des différents poids sur les recommandations. À l'aide de barres empilées, nous avons 
        illustré comment chaque caractéristique contribue aux recommandations pour des films comme Toy Story 2, Cars, A Bug's Life, et The Rescuers. Le graphique a clairement montré que, par 
        exemple, le genre jouait un rôle prépondérant dans la recommandation de Toy Story 2 et The Rescuers, tandis que pour Cars et A Bug's Life, c'était davantage le réalisateur qui influençait 
        les résultats. Cette analyse graphique nous a permis de confirmer que le modèle fonctionne de manière logique, en s'appuyant sur des caractéristiques significatives, ce qui renforce la 
        cohérence et la pertinence des recommandations proposées.
        """)
    
    def get_model_interpretability_part3(self):
        return (""" 
        En somme, l'interprétabilité de ce modèle de recommandations nous a permis de valider que les suggestions faites sont bien justifiées par les données et les caractéristiques des films. 
        Cette approche assure que les utilisateurs peuvent avoir confiance dans les recommandations du système, car elles reposent sur des bases solides et compréhensibles.
        """)
    
    def get_conclusion(self):
        return ("""
        ### Conclusion
        Le modèle développé a réussi à offrir des recommandations personnalisées, et les ajustements des poids ainsi que la fonction de recommandation personnalisée ont joué un rôle clé dans 
        l'optimisation des résultats. Les tests non concluants, quant à eux, ont mis en lumière des domaines nécessitant des ajustements, et nous envisageons de continuer à affiner et à améliorer 
        notre système en testant notamment d’autres modèles.
        """)